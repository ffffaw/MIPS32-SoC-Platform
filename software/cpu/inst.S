   .org 0x0
   .set noat
   .set noreorder
   .set nomacro
   .global _start

_start:
    ori $1,$0,0x100     # $1 = 0x100    # 将0x100赋值给寄存器$1
    lui $2,0x2000       #基地址0x20000000
    jr $1               # 跳转到$1指向的地址
    nop                 # 空操作，延迟槽

.org 0x20           # 设置当前位置为0x20
    mfc0 $1,$13,0x0     # 从协处理器0的cause寄存器读取到$1
    andi $4, $1, 0x0800  # 判断cause里的第11位是否为1
    bne $4,$0,_int2
    nop                 # 延迟槽
    eret                # 从异常返回

    
.org 0x100          # 设置当前位置为0x100
    ori $5,$0,0x000     # $5 = 0x100    # 将0x100赋值给寄存器$1
    ori $6,$0,0x000     # $6 = 0x100    # 将0x100赋值给寄存器$1
    ori $7,$0,0x000     # $5 = 0x100    # 将0x100赋值给寄存器$1
    ori $8,$0,0x000     # $6 = 0x100    # 将0x100赋值给寄存器$1
    ori $9,$0,0x000     # $5 = 0x100    # 将0x100赋值给寄存器$1
    ori $10,$0,0x000     # $6 = 0x100    # 将0x100赋值给寄存器$1
    ori  $3,$0,0x0003      # $1 = 0x3
    sw   $3,0x04($2)    # 到04地址波特率115200
    lui $1,0x1000       # $1 = 0x10000000
    ori $1,$1,0x801     # $1 = $1 | 0x801
    mtc0 $1,$12,0x0     # 将$1写入协处理器0的$12寄存器
    ori  $3,$0,0x0098      # $1 = 0x98
    sw   $3,0x00($2)    # 回写到00地址发送0x98
    ori  $3,$0,0x00f0      # $1 = 0xf0
    sw   $3,0x00($2)    # 回写到00地址发送0xf0
    ori  $3,$0,0x000f      # $1 = 0x0f
    sw   $3,0x00($2)    # 回写到00地址发送0x0f

_loop:
   nop
   j _loop
   nop

 _int2:
    lw   $3,0x00($2)    # 读取内存地址为0x20000000的寄存器的值
    sw   $3,0x00($2)    # 回写到00地址发送
    eret                # 从异常返回
    nop
    nop
   




   
   

